import JSChaCha20 from "js-chacha20";

if (typeof window.crypto == "undefined") {
	const rand = makeRand();
	window.crypto = {
		getRandomBytes(typedArray) {
			for (let i = 0; i < typedArray.length; i++) {
				typedArray[i] = rand(typedArray.BYTES_PER_ELEMENT);
			}
		}
	};
}

function makeRand() {
	// weakRand is used to generate start values.
	// The don't have to be "securely" random, but merely unpredictable.
	function weakRand(size) {
		let buf = new Uint8Array(size);
		for (let i = 0; i < size; i++) {
			buf[i] = Math.round(Math.random() * 256);
		}
		return buf;
	}
	const key = weakRand(32);
	const nonce = weakRand(12);
	const counter = 1;
	const chacha = new JSChaCha20(key, nonce, counter);

	// We will use the same buffer for keeping pre-generated bytes.
	// Start with a buffer of simply anything, as it will be turned into noise anyway.
	let buffer = new Uint8Array(Array(64).fill(1));

	// Pos is the number of invalid buffer bytes.
	let pos = buffer.length;

	// Returns a new random byte.
	function getByte() {
		// If all bytes in the buffer have been invalidated, generate a new one.
		if (pos >= buffer.length) {
			buffer = chacha.encrypt(buffer);
			pos = 0;
		}
		return buffer[pos++];
	}

	// Returns a new random integer of the given size in bytes.
	return function(size) {
		if (size < 1 || size > 16) {
			throw new Error("Invalid size argument: " + size);
		}
		let result = 0;
		while (size > 0) {
			size--;
			result = (result << 8) | getByte();
		}
		return result;
	};
}
